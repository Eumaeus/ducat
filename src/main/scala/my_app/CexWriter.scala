package reader

import com.thoughtworks.binding.{Binding, dom}
import com.thoughtworks.binding.Binding.{BindingSeq, Var, Vars}
import scala.scalajs.js
import scala.scalajs.js._
import org.scalajs.dom._
import org.scalajs.dom.ext._
import org.scalajs.dom.raw._
import edu.holycross.shot.cite._
import edu.holycross.shot.scm._
import edu.holycross.shot.ohco2._
import edu.holycross.shot.citeobj._
import edu.furman.classics.citealign._
import edu.furman.classics.citewriter._
import scala.scalajs.js.Dynamic.{ global => g }
import scala.concurrent._
//import ExecutionContext.Implicits.global

import scala.scalajs.js.annotation.JSExport
import js.annotation._
import monix.execution.Scheduler.Implicits.global
import monix.eval._

@JSExportTopLevel("ReaderCexWriter")
object ReaderCexWriter {

 def getCexUrn:Cite2Urn = {
  val d = new js.Date()
  val nss:String = "urn:cite2:cex:ducatauto."
  val yearMonth:String = s"${d.getFullYear()}${d.getMonth()}"
  val hours:String = s"${d.getHours()}_${d.getMinutes()}_${d.getSeconds()}_${d.getMilliseconds()}"
  val urnString:String = s"${nss}${yearMonth}:${hours}"
  Cite2Urn(urnString)
} 

def downloadCex:Unit = {
  /*
    val task = Task{  saveCex(SaveDialog.defaultFilename.value, assembleCex) }
    val future = task.runAsync
  */
}   

def sortPassages(tr:TextRepository, passages:Vector[CitableNode]):Vector[CitableNode] = {
  val vecUrns:Vector[CtsUrn] = sortUrns(tr, passages.map(_.urn).distinct)
  vecUrns.map(u => {
    passages.find(_.urn == u).get
  })
}

def sortUrns(tr:TextRepository, passages:Vector[CtsUrn]):Vector[CtsUrn] = {
    val passageSet:Set[CtsUrn] = passages.toSet
    val trc = tr.corpus
    val pv:Vector[CtsUrn] = passageSet.toVector.map(u => trc.validReff(u).filter(_.dropPassage == u.dropPassage)).flatten
    val pm:Vector[(CtsUrn,Vector[CtsUrn])] = pv.groupBy(_.dropPassage).toVector
    val workVec:Vector[CtsUrn] = pm.map(work => {
      val thisWorkUrns:Vector[(CtsUrn, Int)] = trc.urns.filter(_.dropPassage == work._1).zipWithIndex
      val theseUrns:Vector[(CtsUrn, Int)] = work._2.map( wu => {
        var thisIndex:Int = thisWorkUrns.find(_._1 == wu).get._2
        (wu, thisIndex)
      })
      theseUrns.sortBy(_._2).map(_._1)
    }).flatten
    workVec
  }

/* Methods for connecting out to Javascript */
@JSGlobal("saveCex")
@js.native
object saveCex extends js.Any {
  def apply(filename:String, data:String): js.Dynamic = js.native  
}


  /* *************************************
        Boilerplate
**************************************** */
     val cexHeader:String = s"""#!cexversion
        |3.0
        |
        |#!citelibrary
        |name#CITE Library generated by the Ducat application, ${new Date()}
        |urn#${getCexUrn}
        |license#CC Share Alike.
        """.stripMargin

      val ctsCatalogHeader:String = """#!ctscatalog
          |urn#citationScheme#groupName#workTitle#versionLabel#exemplarLabel#online#lang""".stripMargin



    } 